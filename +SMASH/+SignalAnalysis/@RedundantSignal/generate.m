% generate Generate redundant measurement
%
% This method generates a redundant measurement for a specified source
% signal and parameter array.
%    object=RedundantSignal.generate(source,parameter);
% The input "source" must be a Signal object, and the input "parameter"
% must be a three-column array with at least two rows (one per
% measurement).
%
% Measurement bounds can be specified as a two-column array [min max].
%    object=RedundantSignal.generate(source,parameter,bound);
% The input "bound" must either have one row (same bounds for all
% measurements) or the same number of rows as measured signals.  Infinite
% bounds are supported, and the default bounds are [-inf +inf] when none
% are specified.
%
% Specifying a fourth input:
%    object=RedundantSignal.generate(source,parameter,bound,noise);
% adds random noise to the measurements.  The input "noise" must be a
% numeric array of RMS values.  Noise is generated by the NoiseSignal
% class using a bandwidth of half the Nyquist limit; advanced users can
% use to invoke that class directly.
%
% See also RedundantSignal, SMASH.SignalAnalysis.NoiseSignal
%

%
% created February 1, 2019 by Daniel Dolan (Sandia National Laboratory)
%
function object=generate(source,parameter,bound,noise)

% manage input
assert(nargin >= 2,'ERROR: insufficient input');
assert(isa(source,'SMASH.SignalAnalysis.Signal'),...
    'ERROR: invalid source object');

assert(isnumeric(parameter) && ismatrix(parameter),...
    'ERROR: invalid parameter array');
assert(size(parameter,2) == 3,'ERROR: parameter array must have 3 columns');
M=size(parameter,1);
assert(M >= 2,'ERROR: two or more signals must be generated');

if (nargin < 3) || isempty(bound)
    bound=repmat([-inf inf],[M 1]);
elseif numel(bound) == 2
    bound=reshape(bound,[1 2]);
    bound=repmat(bound,[M 1]);
else
    assert(size(bound,2) == 2,'ERROR: bound array must have 2 columns');
    assert(size(bound,1) == M,'ERROR: invalid number of bounds');
end

if (nargin < 4) || isempty(bound)
    noise=zeros(M,1);
else
    assert(isnumeric(noise) && all(noise >= 0),'ERROR: invalid noise level(s)');
    if isscalar(noise)
        noise=repmat(noise,[M 1]);
    else
        assert(numel(noise) == M,'ERROR: invalid number of noise values');
        noise=noise(:);
    end
    NoiseMachine=SMASH.SignalAnalysis.NoiseSignal(source.Grid);
    NoiseMachine=defineTransfer(NoiseMachine,'nyquist',1/2);
end

% generate measurements
new=cell(M,1);
label=cell(M,1);
for m=1:M
    new{m}=shift(source,parameter(m,1));
    new{m}=parameter(m,2)*new{m}+parameter(m,3);
    if noise(m) > 0
        NoiseMachine.Amplitude=noise(m);
        NoiseMachine=generate(NoiseMachine);
        new{m}=new{m}+NoiseMachine.Measurement;
    end
    k=new{m}.Data < bound(m,1);
    new{m}=replace(new{m},k,bound(m,1));
    k=new{m}.Data > bound(m,2);
    new{m}=replace(new{m},k,bound(m,2));
    label{m}=sprintf('Signal %d',m);
end
object=SMASH.SignalAnalysis.SignalGroup(new{:});
object.Legend=label;

% crop as necessary
keep=all(~isnan(object.Data),2);
object=reset(object,object.Grid(keep),object.Data(keep,:));

object=SMASH.SignalAnalysis.RedundantSignal(object);

end