% makePeak Generate a peak function handle by name.
%
% This function generates function handles for a named peak function.
%     >> G=makePeak(name);
% Valid names are 'gaussian', 'lorentzian', 'pseudo-voigt','square',
% 'triangle', and 'voigt' (case insenstive).
%
% The handles generated by this function accept two inputs, i.e. G=G(p,x).
% The first input is a parameter array, the second input is an array of
% locations where the function is evaluated.  The parameter array size and
% interpretation depends on the peak name.
%     Gaussian peaks require two parameters: [x0 sigma]
%     Lorentzian peaks require two parameters: [x0 gamma]
%     Pseudo-Voigt peaks require three parameters: [x0 gamma weight]
%     Square peaks require two parameters: [x0 Lx]
%     Triangle peaks require two parameters: [x0 Lx]
%     Voigt peaks require three parameters: [x0 sigma gamma]
% Parameters must be passed each time the function handle is used.
%     >> G=makePeak('gaussian');
%     >> x=linspace(-5,5,1000);
%     >> plot(x,G([0 1],x); % x0=0, sigma=1
%     >> plot(x,G([1 2],x); % x0=1, sigma=2
% The position parameter (x0) can take on any value, but width parameters
% (sigma, gamma, and Lx) must always be greater than zero. Width parameters
% should generally be >1% of the total evaluation range.
%
% Extreme width differences in the Voigt peak may cause very slow function
% evaluation!  If sigma >> gamma, the Voigt peak is nearly Gaussian but
% takes much, much longer to compute.  
%
% By default, error checking (number of inputs, number of parameters, etc.)
% is performed every time the peak function handle is called.  Error checks
% can be bypassed to speed up repetitive function calls.
%     >> G=makePeak(name,'bypass');
%
% See also CurveFit, makeBackground, makeStep
%

%
% created December 2, 2014 by Daniel Dolan (Sandia National Laboratories)
%
function out=makePeak(name,errtest)

% handle input
if (nargin<1) || isempty(name)
    name='gaussian';
end
assert(ischar(name),'ERROR: invalid peak name');

if nargin<2
    errtest='';
end
if strcmpi(errtest,'bypass')
    errtest=false;
else
    errtest=true;
end

% process request
switch lower(name)
    case 'gaussian'
        out=@gaussian_function;
    case 'lorentzian'
        out=@lorentzian_function;
    case {'pseudo-voigt','pseudo_voigt'}
        out=@pseudo_voigt_function;
    case 'square'
        out=@square_function;
    case 'triangle'
        out=@triangle_function;
    case 'voigt'              
        out=@voigt_function;
    otherwise
        error('ERROR: invalid peak name');
end
%%
    function y=gaussian_function(param,x) % [x0 sigma]
        if errtest
            assert(nargin==2,'ERROR: invalid number of inputs');
            assert(numel(param)==2,'ERROR: invalid number of parameters');
            assert(param(2)>0,'ERROR: invalid width parameter');
        end
        x0=param(1);
        sigma=param(2);
        y=exp(-(x-x0).^2/(2*sigma^2));        
    end

%%
    function y=lorentzian_function(param,x) % [x0 gamma]
        if errtest
            assert(nargin==2,'ERROR: invalid number of inputs');
            assert(numel(param)==2,'ERROR: invalid number of parameters');
            assert(param(2)>0,'ERROR: invalid width parameter');
        end
        x0=param(1);
        gamma=param(2);
        y=(x-x0)/gamma;
        y=1./(1+y.^2);
        
    end
%%
    function y=pseudo_voigt_function(param,x) % [x0 gamma w]
        if errtest
            assert(nargin==2,'ERROR: invalid number of inputs');
            assert(numel(param)==3,'ERROR: invalid number of parameters');
            assert(param(2)>0,'ERROR: invalid width parameter');
            assert(param(3)>=0 & param(3)<=1,'ERROR: invalid weight parameter');
        end
        L=lorentzian(param(1:2),x);
        sigma=param(2)/sqrt(2*log(2));
        G=gaussian([param(1) sigma],x);
        w=param(3);
        y=w*L+(1-w)*G;
    end
%%
    function y=square_function(param,x) % [x0 Lx]
        if errtest
            assert(nargin==2,'ERROR: invalid number of inputs');
            assert(numel(param)==2,'ERROR: invalid number of parameters');
            assert(param(2)>0,'ERROR: invalid width parameter');
        end
        x0=param(1);
        Lx=param(2);
        y=zeros(size(x));
        index=abs(x-x0)<(Lx/2);
        y(index)=1;
        
    end
%%
    function y=triangle_function(param,x) % [x0 Lx]
        if errtest
            assert(nargin==2,'ERROR: invalid number of inputs');
            assert(numel(param)==2,'ERROR: invalid number of parameters');
            assert(param(2)>0,'ERROR: invalid width parameter');
        end
        x0=param(1);
        Lx=param(2)/2;       
        y=zeros(size(x));
        slope=1/Lx;
        index=(x>(x0-Lx)) & (x<=x0);
        y(index)=1+slope*(x(index)-x0);
        slope=-slope;
        index=(x>x0) & (x<(x0+Lx));
        y(index)=1+slope*(x(index)-x0);
    end
%% 
    function y=voigt_function(param,x) % [x0 sigma gamma]
        if errtest
            assert(nargin==2,'ERROR: invalid number of inputs');
            assert(numel(param)==3,'ERROR: invalid number of parameters');
            assert(param(2)>0,'ERROR: invalid width parameter');
            assert(param(3)>0,'ERROR: invalid width parameter');
        end
        % access parameters
        x0=param(1);
        sigma=param(2);
        gamma=param(3);
        % apply normalization
        L=max(x)-min(x);
        L=max(L,sigma);
        L=max(L,gamma);        
        sigma=sigma/L;
        gamma=gamma/L;
        % integration
        left= -6*sigma; % more reliable than -inf for small sigma
        right=+6*sigma; % more reliable than +inf for small sigma
        u=(x-x0)/L;
        kernel=@(v) exp(-v.^2/(2*sigma^2))./(1+(u-v).^2/gamma^2);       
        y=integral(kernel,left,right,'ArrayValued',true);
        u=0;
        kernel=@(v) exp(-v.^2/(2*sigma^2))./(1+(u-v).^2/gamma^2);
        y=y/integral(kernel,left,right);
    end
end
